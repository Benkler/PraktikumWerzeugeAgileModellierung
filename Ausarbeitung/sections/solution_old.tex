\chapter{Solution Overview}
\label{ch:Solution}
This chapter provides the solution overview to tackle the issue of microservice identification. Basically, approaches support two types of initial situations: They either conduct the extraction of microservices from existing monolithic systems or they are based on microservice greenfield development. In this thesis, the extraction process is based on the pre-existing system requirements of the case study. Therefore no existing implementation is used and consequently, the presented approach is to be classified as greenfield method.\\
This thesis proposes a formal, graph-based microservice identification approach using clustering techniques and facets of structural and data dependencies extracted from control flow and data flow. The approach is mainly inspired by Amiri's  work on \textit{Object-aware Identification of Microservices}. Hereafter, the approach \cite{ObjectAwareAmiri} is shortly introduced as a solution to \textbf{RQ1}. Sec.\ref{sec:solutionOverview:Contributions} suggests the improvements that form the basis of the approach proposed by this thesis \textbf{(RQ2)}.


\section{Basic Concept}
\label{sec:solutionOverview:basicConcept}
Basically, the identification process is performed from the business process point of view. A business process is a set of activities where each activity represents a functionality within the system in order to achieve a business goal. To organize a system as suite of small and independent microservices, the business processes are decomposed into fine-grained, cohesive and loosely coupled components where the activities are distribute among those components and each of the components represents a microservice.\\



\subsection{Available Extraction Strategy}
\label{sec:solutionOverview:basicStrategy}
The partitioning process is based on the structural dependency of the activities and furthermore based on the data object dependencies regarding the read and write operation the activities perform on data objects. To promote the property of high cohesiveness, two activities are more likely to be partitioned into the same microservice if they are close or even directly connected through an edge. Besides, it is desirable to partition activities into the same microservice with similar data access . \\
Technically, the activities are represented by \textit{BPMN}\footnote{Business Process Model an Notation} business processes which are replenished with data read and writes. The approach uses two relations to represent the previously mentioned structural and data object dependencies, which are aggregated and clustered to obtain possible microservice candidates. \\
Both relations are represented in a distinct matrix. Each pair of activities form a matrix entry.
Regarding the structural dependency, the values are 1, if there is a direct edge or only gateways between both activities. Otherwise, it is 0. Considering the data objects dependency, the values depend on the data objects the activities read or write. More specifically, objects written by both activities generate a value of 1, objects written by one and read by the other 0.5 and objects read by both activities 0.25. The resulting value ending up as matrix entry is the amount of objects multiplied by the factors mentioned beforehand.\\
The final matrix is generated by aggregating, specifically adding both matrices. Second to last, a weighted graph is generated, where the nodes are represented by the activities and the weights for the edges correspond to the values of the final matrix. In the final analysis, a graph based clustering tool called \textit{Bunch} \footnote{https://www.cs.drexel.edu/~spiros/bunch/} generates clusters that represent possible microservice candidates.

\subsection{Weakness}
When it comes to evaluate the approach presented by Amiri, the method used to weight the relationships attracts attention. First of all, there is no mathematical or empirical evidence that the aggregation of the two relationships can be achieved by simply adding the two matrices. By the same token, the proposed weights that describe the data object dependency lack a formal explanation. Even more important, the approach does not consider the difference between data object access within a microservice and remote data access to another microservice. Precisely, a remote call to access data in another microservice, no matter if read or write, is far more time consuming than a local call. It is therefore dispensable to differentiate between read and write access. \\
 

\section{Contributions}
\label{sec:solutionOverview:Contributions}
First of all, the suggested solution adopts the basic idea to perform the identification from the business point of view. Therefore, the informal system specifications of the case study provided as use cases are visualized as \textit{BPMN} processes using the approach proposed by Luebke et al. \cite{Lubke}.
Further, the goal is to achieve a proper representation of data object and structural dependency. Therefore, a main contribution consists of carving out possible relationships between data objects and activities.\\
Regarding data objects, a possible relationship can be identified using a distance measure based on the principle of locality. Given a pair of data objects and corresponding activities that access the data: It is more likely that both data objects belong to the same service if they are accessed by neighbouring activities. Otherwise, they should be partitioned in different services.\\
Another strategy is based on the cohesiveness of microservices, and consequently the cohesiveness of its data: Two data objects are more likely part of the same service, if several activities access both of them together. \\
In order to eliminate the ambiguity of the aggregation, the proposed approach uses independent clustering for the structural and data object dependency. Having both sets of cluster, the next step is to match them together which might lead to merging or splitting some of the clusters. \\
So far, it remains unclear how to match, merge and split them. This will be elaborated within this thesis. A schedule for the execution of the thesis can be found in Chapter \ref{ch:timetable}.









